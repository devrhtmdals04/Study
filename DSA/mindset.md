# 💡 알고리즘 직관을 키우는 사고법: "왜 나는 이 풀이가 떠오르지 않을까?"

알고리즘 문제를 풀다가 정석적인 깔끔한 풀이를 보고 "왜 나는 이 생각을 못 했을까?"라고 자책하는 것은 **모든 개발자가 겪는 필연적인 성장통**입니다. 머리가 나쁜 것이 아니라, **접근 방식(Mental Model)**이 다르기 때문입니다.

이 문서는 그 사고의 간극을 줄이기 위한 3가지 핵심 전략과 액션 플랜을 정리한 노트입니다.

---

## 1. 함정: 구현(How)부터 생각하지 말고 본질(What)을 정의하라

우리는 문제르 보면 습관적으로 "컴퓨터에게 어떻게 시킬까?"(for문, if문)를 먼저 고민합니다. 하지만 고수들의 직관은 "이 문제의 핵심이 뭐지?"에서 출발합니다.

* **하수 (Syntax First):** "이중 반복문을 돌려서 모든 경우를 비교해볼까? 아, 시간 초과나네."
* **고수 (Semantics First):** "주식으로 돈을 벌려면? 결국 **'오늘 팔 때, 과거 중 제일 쌀 때 샀으면 됨'** 이거 하나잖아?"
    * 결론: "복잡한 비교 필요 없이 **'과거의 최저가' 변수 하나**만 기억하면 끝이네."

> **🔑 훈련법:** > 코드를 짜기 전 키보드에서 손을 떼세요. 친구에게 설명하듯이 **"결국 이 문제는 OO만 알면 끝나는 거 아냐?"** 라는 한 문장을 찾으세요.

---

## 2. 시뮬레이션: 뇌를 믿지 말고 '손'을 믿어라

코드를 바로 짜려고 하면 뇌는 '문법(Syntax)'과 '논리(Logic)'를 동시에 처리하느라 과부하가 걸려 직관이 발휘되지 않습니다.

* **눈과 손으로 풀기 (Longest Consecutive Sequence 예시):**
    * `[100, 4, 200, 1, 3, 2]`라는 숫자를 종이에 적고 손가락으로 짚어봅니다.
    * 사람의 눈은 `1`을 보자마자 본능적으로 `2`를 찾고, `3`, `4`를 연결합니다.
    * 이 과정에서 **"어? 중간 숫자는 별로 안 중요하고, 덩어리(Cluster)들이 뭉쳐지네?"** 라는 느낌을 받습니다.
* **이 느낌이 곧 알고리즘입니다.**
    * "눈으로 2를 찾는다" → Lookup($O(1)$) 필요 → **Set/Dict 사용**
    * "덩어리가 뭉쳐진다" → **양옆(Boundary)을 확인**해서 합치자.

> **🔑 훈련법:** > 예제 데이터를 종이에 쓰고, 손가락으로 직접 데이터를 옮기거나 지워보세요. **내 손이 무의식적으로 하는 행동**을 코드로 옮기는 것이 가장 효율적인 알고리즘인 경우가 많습니다.

---

## 3. 도구 상자: 직관은 '천재성'이 아니라 '기억된 패턴'이다

"직관"이라고 부르는 것의 90%는 사실 **"기억해 둔 패턴의 변형"**입니다. 깔끔한 코드를 짠 사람은 천재라서 즉석에서 만든 게 아니라, 도구 상자에서 적절한 도구를 꺼낸 것입니다.

* **오늘 획득한 도구:**
    1.  **구간 병합 (Union-Find 응용):** `mp[num - left]`, `mp[num + right]` 처럼 양 끝값만 갱신하면 전체가 연결된다.
    2.  **그리디 (Greedy):** 과거의 모든 데이터를 들고 다닐 필요 없이, `min_price` 같은 핵심 대푯값 하나만 갱신하며 들고 다니면 된다.

> **🔑 훈련법:** > 풀이를 보고 감탄하는 데서 그치지 말고, **"이건 OO 패턴이다"**라고 이름을 붙여 내 도구 상자에 넣으세요. 다음에 비슷한 문제를 보면 뇌가 반응할 것입니다.

---

## 🚀 실전 액션 플랜 (다음 문제를 만났을 때)

문제를 마주하고 딱 **5분**만 투자를 하세요.

1.  **제약 조건 확인 (무기 선택):**
    * "입력이 10만 개네? $O(N^2)$은 절대 안 된다. 무조건 $O(N)$이나 $O(N \log N)$이어야 해." (사용 가능한 알고리즘을 좁힘)
2.  **단순화 (Simplification):**
    * "가장 멍청하고 단순하게 사람이 푼다면 어떻게 할까?"를 상상하고, 거기서 불필요한 중복 행위를 제거합니다.
3.  **시각화 (Visualization):**
    * 데이터를 그림으로 그리고 손으로 이어보거나 묶어보세요.

> **"지금 느끼는 그 답답함이 실력이 늘고 있다는 증거입니다. 몰랐던 패턴을 뇌에 새기는 중이니까요."**

# 🚀 알고리즘 직관을 코드로 옮기는 마인드셋 (Mindset Cheat Sheet)

 직관은 오는데 손이 멈출 때, 확신이 없을 때를 위한 행동 지침

## 1. 구현의 벽 넘기: "3단계 번역"

코드를 처음부터 문법에 맞춰 완벽하게 쓰려고 하지 마세요.

1.  **Phase 1: 한글 주석 (Pseudocode)**
    * 문법, 컴파일러 신경 쓰지 말고 논리의 순서를 **한글로** 적는다.
    * 예: "정렬 먼저 하고, 반복문 돌면서 앞차랑 시간 비교해서..."
2.  **Phase 2: 한 줄 번역 (Translation)**
    * 한글 주석 밑에 해당하는 파이썬 코드를 한 줄씩 채워 넣는다.
3.  **Phase 3: 패턴 적용 (Toolbox)**
    * 자주 쓰는 패턴을 꺼낸다. (예: `sorted(zip(...))`, `stack[-1]`)

---

## 2. 완벽주의 깨부수기: "작가 vs 편집자"

코드를 짜는 동안(작가)에는 검증(편집자)을 하지 마세요.

* **작가와 편집자 분리:** "일단 돌아가는 쓰레기(Working Garbage)를 만든다."
* **주차장 기법 (Parking Lot):**
    * 코딩 중 "이런 반례(Edge Case)가 있으면 어떡하지?"라는 불안이 들면?
    * 멈추지 말고 **`# TODO: 속도가 0일 때 확인 필요`** 라고 주석만 박아두고 메인 로직으로 넘어간다.
    * 반례 처리는 메인 로직이 완성된 후, 나중에 하는 것이다.
* **건축이 아니라 '점토 공예':**
    * 기초가 무너질까 걱정하지 말자. 뭉뚝하게 빚어놓고, 터지면 그때 덧붙이거나 깎아내면 된다.

---

## 3. 자료구조 선택의 확신: "일단 쓴다 → 줄인다"

"스택을 써야 하나? 변수만 써도 되나?" 고민으로 시간을 쓰지 마세요.

* **Step 1. 가장 만만한 도구(Stack/List)로 먼저 짠다.**
    * 과거 데이터가 필요한지 아닌지 헷갈리면, 일단 다 저장하는 스택을 써라. (논리적으로 안전함)
* **Step 2. "어? 안 쓰네?"를 발견한다.**
    * 코드를 다 짜고 보니 `stack[-1]`(직전 값)만 보고, `stack[:-2]`(그 이전 값)는 안 본다면?
* **Step 3. 그때 변수로 바꾼다 (Refactoring).**
    * 이 과정이 바로 '최적화'다. 처음부터 최적의 도구를 못 골랐다고 자책할 필요 없다.

> **💡 Car Fleet 예시:**
> 처음엔 `stack`에 다 넣는 코드를 짠다 -> 짜고 보니 "직전 `time`이랑만 비교하네?" -> `current_max_time` 변수 하나로 교체!

---

## ⚡ 코딩 테스트 핵심 만트라

1.  **"직감은 틀리지 않았다. 다만 번역이 필요할 뿐."**
2.  **"반례가 생기면? 그때 고치면 된다. 디버깅은 나의 힘."**
3.  **"Best Practice를 한 번에 찾으려 하지 마라. Refactoring이 답이다."**